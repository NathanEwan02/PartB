# Workbook T2A1-B

## Q1. Identify and explain the workings of TWO sorting algorithms and discuss and compare their performance/efficiency (i.e. Big O) <br></br>

### A) Merge Sort:
The merge sort algorithm works operates by taking an array of unsorted elements and performing what is known as a 'merge sort'. This method of sorting operates by dividing the list in half repeatedly until each element within the array has been separated from the others. This is typically done through the use of recursion. For example, the merge sort function would take in an array as an argument, that function would then call itself on the left array and again on the right array. This way each array would be broken down more and more until each element in the original array has been separated and are by isolated. The next step of the algorithm is to then, run a while loop to begin merging the elements back together. The if statements in the while loops will check if the right element is less than the value of the left element. If it is then the elements will be swapped and merged together, if they arenâ€™t they will be merged as they are currently. This process will be continued with each left and right array until there are only two arrays left at which point they will compare the values and complete the cycle by merging together with the final sorted array. This algorithm has an time complexity of O(nlogn). This type of time complexity is similar to O(logn) however, unlike a logarithmic algorithm which can be seen in an example of a binary search which  halves the input size though each iteration. A merge sort however is O(n * logn) which means the algorithm is of loglinear complexity and means that the O(logn) operation will occur n times.<br></br>

### B) Bubble Sort
A bubble sort works by comparing the first and second elements of an array against each other and then deciding whether the first is smaller or larger than the second element. If it is larger they will be swapped with each other and the algorithm will move to the second and third. If the first is smaller then the algorithm will move straight to comparing the second and third. This will continue until it reaches the end of the array, which is the first iteration. The algorithm will then continue to do iterations over the array until it has been completely sorted. This means that this algorithm is of O(n^2) time complexity because the algorithm operates on two loops, the loop that iterates over the length of the arrays and the one that traverses that array. 

## Identify and explain the workings of TWO search algorithms and discuss and compare their performance/efficiency (i.e. Big O) <br></br>

### A) Linear Search
A linear search algorithm operates by searching through an array of elements one by one staring at the first element in that array. The algorithm first needs to be given the length of the array and a counter is set to 0. Each time the algorithm will compare the element to the intended value and will increase the counter by one until the value is found. Once the value is found it is outputted to the user. This algorithm operates at an average time complexity of O(n). This means that the time taken to search through the list is increased linearly by n, which is the size of the dataset/array.

### B) Binary Search
A binary search operates by finding the middle of a given array and then checking to see if that element is the value that the algorithm is looking for. If not, then the algorithm continues by first determining whether the value being searched for is less than or greater than the current element. If the element is greater than the current element, then the algorithm will find the mid-way point between the last element in the list and the current element and then set the current element to that specific mid-way point. If the opposite is true, then the algorithm will find the mid-way point between the current element and the first in the array and set the current value to that. The array will continue to be split in half until the current element is equal to the value the algorithm was searching for. This is a highly efficient algorithm as it operates on an average time complexity of O(logn). This means that each time the element is searched for, the data set is split in half. This makes it a fast algorithm because even if the data set is very large, it will be split in half each time. 

# References
- BBC Bitesize. n.d. Linear search - Algorithms - Edexcel - GCSE Computer Science Revision - Edexcel - BBC Bitesize. [online] Available at: <https://www.bbc.co.uk/bitesize/guides/z7kkw6f/revision/7> [Accessed 20 November 2021].

- Piterman, S., 2020. Breaking Down MergeSort. [online] Medium. Available at: <https://medium.com/outco/breaking-down-mergesort-924c3a55c969> [Accessed 21 November 2021].